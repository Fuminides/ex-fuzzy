
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ex_fuzzy.evolutionary_fit_regression &#8212; Ex-Fuzzy 1.0.0</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=edfbbfd1" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=30646c52"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/ex_fuzzy/evolutionary_fit_regression';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="1.0.0" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs..."
         aria-label="Search the docs..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo-light.png" class="logo__image only-light" alt=""/>
    <img src="../../_static/logo-dark.png" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">Ex-Fuzzy</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../getting-started.html">
    Getting Started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../installation.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user-guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user-guide/regression.html">
    Fuzzy Regression
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../evox_backend.html">
    EvoX Backend Guide
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button"
                data-bs-toggle="dropdown" aria-expanded="false"
                aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../api/index.html">
    API Reference
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../api/fuzzy_sets.html">
    Fuzzy Sets
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../api/classifiers.html">
    Classifiers Module
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../api/evolutionary_fit.html">
    Evolutionary Fit Module
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../api/regression.html">
    Fuzzy Regression (API)
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../api/eval_tools.html">
    Evaluation Tools Module
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../contributing.html">
    Contributing
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../changelog.html">
    Changelog
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../roadmap.html">
    Roadmap
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../usage.html">
    Getting Started
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../step1.html">
    Creating fuzzy sets and fuzzy variables
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../step2.html">
    Using Fuzzy Rules
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../step3.html">
    Optimizing a Fuzzy rule base for a classification problem
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../step4.html">
    Visualize rules and results
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../precom.html">
    Computing fuzzy partitions
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../optimize.html">
    Genetic algorithm details
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../gt2.html">
    General Type 2
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../tmpfs.html">
    Temporal Fuzzy Sets
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../extending.html">
    Extending Ex-Fuzzy
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../persistence.html">
    Persistence
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../classifiers.html">
    Advanced classifiers
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../pattern_stats.html">
    Bootstrapping and rule robustness
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
        </div>
      
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/fuminides/ex-fuzzy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-github-square fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/ex-fuzzy/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fas fa-box fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../getting-started.html">
    Getting Started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../installation.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user-guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user-guide/regression.html">
    Fuzzy Regression
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../evox_backend.html">
    EvoX Backend Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/index.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/fuzzy_sets.html">
    Fuzzy Sets
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/classifiers.html">
    Classifiers Module
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/evolutionary_fit.html">
    Evolutionary Fit Module
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/regression.html">
    Fuzzy Regression (API)
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/eval_tools.html">
    Evaluation Tools Module
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../contributing.html">
    Contributing
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../changelog.html">
    Changelog
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../roadmap.html">
    Roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../usage.html">
    Getting Started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../step1.html">
    Creating fuzzy sets and fuzzy variables
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../step2.html">
    Using Fuzzy Rules
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../step3.html">
    Optimizing a Fuzzy rule base for a classification problem
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../step4.html">
    Visualize rules and results
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../precom.html">
    Computing fuzzy partitions
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../optimize.html">
    Genetic algorithm details
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../gt2.html">
    General Type 2
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../tmpfs.html">
    Temporal Fuzzy Sets
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../extending.html">
    Extending Ex-Fuzzy
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../persistence.html">
    Persistence
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../classifiers.html">
    Advanced classifiers
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../pattern_stats.html">
    Bootstrapping and rule robustness
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/fuminides/ex-fuzzy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-github-square fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/ex-fuzzy/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fas fa-box fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">ex_fuzzy.evolutionary_fit_regression</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for ex_fuzzy.evolutionary_fit_regression</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Evolutionary Optimization for Fuzzy Regression Rule Base Learning</span>

<span class="sd">This module extends the evolutionary_fit module to support regression problems</span>
<span class="sd">with numeric outputs. It implements genetic algorithm-based optimization for</span>
<span class="sd">learning fuzzy rule bases where rules output numeric values instead of classes.</span>

<span class="sd">Main Components:</span>
<span class="sd">    - FitRuleBaseRegression: Optimization problem class for regression</span>
<span class="sd">    - BaseFuzzyRulesRegressor: Main regressor interface (like BaseFuzzyRulesClassifier)</span>
<span class="sd">    - Fitness functions using MSE/RMSE instead of classification metrics</span>
<span class="sd">    - Support for numeric consequents in rules</span>

<span class="sd">Key Features:</span>
<span class="sd">    - Numeric rule consequents (output is a real number)</span>
<span class="sd">    - MSE/RMSE-based fitness evaluation</span>
<span class="sd">    - Support for Type-1, Type-2 fuzzy systems</span>
<span class="sd">    - Parallel evaluation support</span>
<span class="sd">    - Both PyMoo and EvoX backends supported</span>
<span class="sd">    - Memory-efficient batch processing for large datasets</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">RegressorMixin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">mean_squared_error</span><span class="p">,</span> <span class="n">mean_absolute_error</span><span class="p">,</span> <span class="n">r2_score</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymoo.core.problem</span><span class="w"> </span><span class="kn">import</span> <span class="n">Problem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymoo.core.variable</span><span class="w"> </span><span class="kn">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Real</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymoo.parallelization.starmap</span><span class="w"> </span><span class="kn">import</span> <span class="n">StarmapParallelization</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing.pool</span><span class="w"> </span><span class="kn">import</span> <span class="n">ThreadPool</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">evolutionary_backends</span> <span class="k">as</span> <span class="n">ev_backends</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">fuzzy_sets</span> <span class="k">as</span> <span class="n">fs</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">rules</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">eval_rules</span> <span class="k">as</span> <span class="n">evr</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.evolutionary_fit</span><span class="w"> </span><span class="kn">import</span> <span class="n">FitRuleBase</span>  <span class="c1"># Reuse most functionality</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">evolutionary_backends</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ev_backends</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">fuzzy_sets</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">fs</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">rules</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">eval_rules</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">evr</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">evolutionary_fit</span><span class="w"> </span><span class="kn">import</span> <span class="n">FitRuleBase</span>


<div class="viewcode-block" id="FitRuleBaseRegression">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.FitRuleBaseRegression">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FitRuleBaseRegression</span><span class="p">(</span><span class="n">FitRuleBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Class to model regression problems for fuzzy rule bases using evolutionary strategies.</span>
<span class="sd">    Rules have numeric consequents instead of class labels.</span>
<span class="sd">    </span>
<span class="sd">    Extends FitRuleBase but overrides evaluation functions to use regression metrics (MSE/RMSE)</span>
<span class="sd">    instead of classification metrics (MCC).</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="FitRuleBaseRegression.__init__">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.FitRuleBaseRegression.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">nRules</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nAnts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">thread_runner</span><span class="p">:</span> <span class="n">StarmapParallelization</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">linguistic_variables</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">fuzzyVariable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_linguistic_variables</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="o">=</span><span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">categorical_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">rule_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;additive&#39;</span><span class="p">,</span> <span class="n">backend_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;pymoo&#39;</span><span class="p">,</span>
                 <span class="n">consequent_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;crisp&#39;</span><span class="p">,</span> <span class="n">output_fuzzy_sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_output_linguistic_variables</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">universe_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Constructor method for regression problem.</span>

<span class="sd">        :param X: np array or pandas dataframe samples x features.</span>
<span class="sd">        :param y: np vector containing the target values (continuous). vector sample</span>
<span class="sd">        :param nRules: number of rules to optimize.</span>
<span class="sd">        :param nAnts: max number of antecedents to use.</span>
<span class="sd">        :param y_range: tuple (min, max) for the output range. If None, computed from data.</span>
<span class="sd">        :param linguistic_variables: list of linguistic variables precomputed. If given, the rest of conflicting arguments are ignored.</span>
<span class="sd">        :param n_linguistic_variables: number of linguistic variables per antecedent.</span>
<span class="sd">        :param fuzzy_type: Define the fuzzy set or fuzzy set extension used as linguistic variable.</span>
<span class="sd">        :param domain: list with the upper and lower domains of each input variable. If None (as default) it will establish the empirical min/max as the limits.</span>
<span class="sd">        :param tolerance: float. Tolerance for rule firing (used only in &#39;sufficient&#39; mode).</span>
<span class="sd">        :param alpha: float. Weight for the rulebase size term in the fitness function. (Penalizes number of rules)</span>
<span class="sd">        :param beta: float. Weight for the average rule size term in the fitness function.</span>
<span class="sd">        :param rule_mode: str. &#39;additive&#39; (all rules contribute) or &#39;sufficient&#39; (only rules above tolerance).</span>
<span class="sd">        :param backend_name: str. Backend to use for evolutionary optimization (&#39;pymoo&#39; or &#39;evox&#39;)</span>
<span class="sd">        :param consequent_type: str. &#39;crisp&#39; (numeric outputs) or &#39;fuzzy&#39; (fuzzy set outputs with defuzzification).</span>
<span class="sd">        :param output_fuzzy_sets: list of fuzzy sets for output (Mamdani). If None, will be evolved.</span>
<span class="sd">        :param n_output_linguistic_variables: int. Number of output linguistic variables if not precomputed.</span>
<span class="sd">        :param universe_points: int. Number of discretization points for fuzzy inference.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># Store target values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">values</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span> <span class="o">=</span> <span class="n">nRules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">=</span> <span class="n">nAnts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nCons</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># This is fixed to MISO rules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rule_mode</span> <span class="o">=</span> <span class="n">rule_mode</span>  <span class="c1"># &#39;additive&#39; or &#39;sufficient&#39;</span>
        
        <span class="c1"># Determine output range</span>
        <span class="k">if</span> <span class="n">y_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">y_range</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend_name</span> <span class="o">=</span> <span class="n">backend_name</span>
        
        <span class="c1"># Mamdani inference parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">=</span> <span class="n">consequent_type</span>  <span class="c1"># &#39;crisp&#39; or &#39;fuzzy&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="n">output_fuzzy_sets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_output_lvs</span> <span class="o">=</span> <span class="n">n_output_linguistic_variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe_points</span> <span class="o">=</span> <span class="n">universe_points</span>
        
        <span class="c1"># Create discretized universe for Mamdani inference</span>
        <span class="k">if</span> <span class="n">consequent_type</span> <span class="o">==</span> <span class="s1">&#39;fuzzy&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">,</span> <span class="n">universe_points</span><span class="p">)</span>
        
        <span class="c1"># Initialize fuzzy variables (reuse parent class logic)</span>
        <span class="k">if</span> <span class="n">categorical_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">categorical_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">categorical_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorical_mask</span>

        <span class="k">if</span> <span class="n">linguistic_variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_precomputed_vl</span><span class="p">(</span><span class="n">linguistic_variables</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_linguistic_variables</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">n_linguistic_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_linguistic_variables</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_optimize_vl</span><span class="p">(</span>
                <span class="n">fuzzy_type</span><span class="o">=</span><span class="n">fuzzy_type</span><span class="p">,</span> <span class="n">n_linguist_variables</span><span class="o">=</span><span class="n">n_linguistic_variables</span><span class="p">,</span> 
                <span class="n">categorical_variables</span><span class="o">=</span><span class="n">categorical_mask</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute min/max bounds</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">min_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">max_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">min_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">max_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">][</span><span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">])]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">antecedents_referencial</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="c1"># Build variable bounds (antecedents same as classification)</span>
        <span class="n">possible_antecedent_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">)</span>
        <span class="n">vl_antecedent_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">)</span>
        <span class="n">antecedent_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">possible_antecedent_bounds</span><span class="p">,</span> <span class="n">vl_antecedent_bounds</span><span class="p">))</span>
        <span class="n">vars_antecedent</span> <span class="o">=</span> <span class="p">{</span><span class="n">ix</span><span class="p">:</span> <span class="n">Integer</span><span class="p">(</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">antecedent_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">antecedent_bounds</span><span class="p">))}</span>
        <span class="n">aux_counter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vars_antecedent</span><span class="p">)</span>

        <span class="c1"># Membership function parameters (if optimizing)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_domain_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
                <span class="n">correct_size</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">[</span><span class="n">ixx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">ixx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">))]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
                <span class="n">correct_size</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">[</span><span class="n">ixx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">ixx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">))]</span>
            <span class="n">membership_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_domain_bounds</span><span class="p">[</span><span class="n">ixx</span><span class="p">]]</span> <span class="o">*</span> <span class="n">correct_size</span><span class="p">[</span><span class="n">ixx</span><span class="p">]</span> <span class="k">for</span> <span class="n">ixx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">))])</span>

            <span class="n">vars_memberships</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">aux_counter</span> <span class="o">+</span> <span class="n">ix</span><span class="p">:</span> <span class="n">Integer</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">membership_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">membership_bounds</span><span class="p">))}</span>
            <span class="n">aux_counter</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vars_memberships</span><span class="p">)</span>

        <span class="c1"># CONSEQUENTS: Different encoding for crisp vs fuzzy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">==</span> <span class="s1">&#39;crisp&#39;</span><span class="p">:</span>
            <span class="c1"># Crisp: Consequents are real numbers normalized to [0, 99]</span>
            <span class="n">final_consequent_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">99</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">)</span>
            <span class="n">vars_consequent</span> <span class="o">=</span> <span class="p">{</span><span class="n">aux_counter</span> <span class="o">+</span> <span class="n">ix</span><span class="p">:</span> <span class="n">Integer</span><span class="p">(</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">final_consequent_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">final_consequent_bounds</span><span class="p">))}</span>
            <span class="n">aux_counter</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vars_consequent</span><span class="p">)</span>
            
            <span class="c1"># Build final variables dict (no output MFs)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="n">vars_antecedent</span><span class="p">,</span> <span class="n">vars_memberships</span><span class="p">,</span> <span class="n">vars_consequent</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">varbound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">antecedent_bounds</span><span class="p">,</span> <span class="n">membership_bounds</span><span class="p">,</span> <span class="n">final_consequent_bounds</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="n">vars_antecedent</span><span class="p">,</span>
                                           <span class="n">vars_consequent</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">varbound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">antecedent_bounds</span><span class="p">,</span> <span class="n">final_consequent_bounds</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mamdani: Consequents are indices to output fuzzy sets</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Precomputed output fuzzy sets</span>
                <span class="n">n_output_fs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Will evolve output fuzzy sets</span>
                <span class="n">n_output_fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_output_lvs</span>
            
            <span class="c1"># Consequent indices</span>
            <span class="n">consequent_index_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_output_fs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">)</span>
            <span class="n">vars_consequent</span> <span class="o">=</span> <span class="p">{</span><span class="n">aux_counter</span> <span class="o">+</span> <span class="n">ix</span><span class="p">:</span> <span class="n">Integer</span><span class="p">(</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">consequent_index_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">consequent_index_bounds</span><span class="p">))}</span>
            <span class="n">aux_counter</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vars_consequent</span><span class="p">)</span>
            
            <span class="c1"># Output membership functions (if not precomputed)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Encode output fuzzy sets similar to input fuzzy sets</span>
                <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
                    <span class="n">output_mf_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_output_fs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span>
                <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
                    <span class="n">output_mf_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_output_fs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span>
                
                <span class="n">output_mf_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">99</span><span class="p">]]</span> <span class="o">*</span> <span class="n">output_mf_size</span><span class="p">)</span>
                <span class="n">vars_output_mf</span> <span class="o">=</span> <span class="p">{</span><span class="n">aux_counter</span> <span class="o">+</span> <span class="n">ix</span><span class="p">:</span> <span class="n">Integer</span><span class="p">(</span>
                    <span class="n">bounds</span><span class="o">=</span><span class="n">output_mf_bounds</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_mf_bounds</span><span class="p">))}</span>
                
                <span class="c1"># Build final variables dict with output MFs</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="n">vars_antecedent</span><span class="p">,</span> <span class="n">vars_memberships</span><span class="p">,</span> <span class="n">vars_consequent</span><span class="p">,</span> <span class="n">vars_output_mf</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    <span class="n">varbound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">antecedent_bounds</span><span class="p">,</span> <span class="n">membership_bounds</span><span class="p">,</span> <span class="n">consequent_index_bounds</span><span class="p">,</span> <span class="n">output_mf_bounds</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="n">vars_antecedent</span><span class="p">,</span>
                                               <span class="n">vars_consequent</span><span class="p">,</span> <span class="n">vars_output_mf</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    <span class="n">varbound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">antecedent_bounds</span><span class="p">,</span> <span class="n">consequent_index_bounds</span><span class="p">,</span> <span class="n">output_mf_bounds</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Precomputed output fuzzy sets</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="n">vars_antecedent</span><span class="p">,</span> <span class="n">vars_memberships</span><span class="p">,</span> <span class="n">vars_consequent</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    <span class="n">varbound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">antecedent_bounds</span><span class="p">,</span> <span class="n">membership_bounds</span><span class="p">,</span> <span class="n">consequent_index_bounds</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="n">vars_antecedent</span><span class="p">,</span>
                                               <span class="n">vars_consequent</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    <span class="n">varbound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">antecedent_bounds</span><span class="p">,</span> <span class="n">consequent_index_bounds</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># No weights needed for additive regression</span>
        <span class="n">nVar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varbound</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_gen_size</span> <span class="o">=</span> <span class="n">nVar</span>

        <span class="c1"># Initialize Problem parent</span>
        <span class="k">if</span> <span class="n">thread_runner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Problem</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="nb">vars</span><span class="o">=</span><span class="nb">vars</span><span class="p">,</span>
                <span class="n">n_var</span><span class="o">=</span><span class="n">nVar</span><span class="p">,</span>
                <span class="n">n_obj</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">vtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                <span class="n">xl</span><span class="o">=</span><span class="n">varbound</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">xu</span><span class="o">=</span><span class="n">varbound</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">elementwise_runner</span><span class="o">=</span><span class="n">thread_runner</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Problem</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="nb">vars</span><span class="o">=</span><span class="nb">vars</span><span class="p">,</span>
                <span class="n">n_var</span><span class="o">=</span><span class="n">nVar</span><span class="p">,</span>
                <span class="n">n_obj</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">elementwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">vtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                <span class="n">xl</span><span class="o">=</span><span class="n">varbound</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">xu</span><span class="o">=</span><span class="n">varbound</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_construct_ruleBase_regression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">:</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">rules</span><span class="o">.</span><span class="n">MasterRuleBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Construct a rule base with numeric consequents for regression.</span>
<span class="sd">        </span>
<span class="sd">        Similar to parent&#39;s _construct_ruleBase but consequents are real numbers.</span>
<span class="sd">        </span>
<span class="sd">        :param x: gene array</span>
<span class="sd">        :param fuzzy_type: fuzzy set type</span>
<span class="sd">        :return: MasterRuleBase with numeric consequents</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">rule_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Single list for regression (no classes)</span>
        
        <span class="n">mf_size</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span> <span class="k">else</span> <span class="mi">6</span>
        
        <span class="c1"># Calculate pointer to consequents (no weights in additive regression)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
                <span class="n">fourth_pointer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span> <span class="o">+</span> \
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
            <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
                <span class="n">fourth_pointer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span> <span class="o">+</span> \
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mf_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fourth_pointer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span>

        <span class="c1"># Handle mixed data types</span>
        <span class="n">min_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">max_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
                <span class="n">min_domain</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="n">max_domain</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_domain</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">max_domain</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">][</span><span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">])]))</span>

        <span class="n">range_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],))</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">range_domain</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_domain</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_domain</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Convert gene to int array</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Reconstruct rules</span>
        <span class="n">aux_pointer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">):</span>
            <span class="n">first_pointer</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span>
            <span class="n">chosen_ants</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">first_pointer</span><span class="p">:</span><span class="n">first_pointer</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">]</span>

            <span class="n">second_pointer</span> <span class="o">=</span> <span class="p">(</span><span class="n">i0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">)</span>
            <span class="n">antecedent_parameters</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">second_pointer</span><span class="p">:</span><span class="n">second_pointer</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">]</span>

            <span class="n">init_rule_antecedents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],))</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># -1 is don&#39;t care</span>

            <span class="k">for</span> <span class="n">jx</span><span class="p">,</span> <span class="n">ant</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chosen_ants</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">antecedent_parameters</span><span class="p">[</span><span class="n">jx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">antecedent_parameters</span><span class="p">[</span><span class="n">jx</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lvs</span><span class="p">[</span><span class="n">ant</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">antecedent_parameters</span><span class="p">[</span><span class="n">jx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">antecedent_parameters</span><span class="p">[</span><span class="n">jx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">[</span><span class="n">ant</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">init_rule_antecedents</span><span class="p">[</span><span class="n">ant</span><span class="p">]</span> <span class="o">=</span> <span class="n">antecedent_parameters</span><span class="p">[</span><span class="n">jx</span><span class="p">]</span>

            <span class="c1"># CONSEQUENT: Depends on consequent_type</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">==</span> <span class="s1">&#39;crisp&#39;</span><span class="p">:</span>
                <span class="c1"># Crisp: Consequent is a real number (denormalize from [0, 99] to [y_min, y_max])</span>
                <span class="n">consequent_normalized</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">fourth_pointer</span> <span class="o">+</span> <span class="n">aux_pointer</span><span class="p">]</span>
                <span class="n">consequent_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">consequent_normalized</span> <span class="o">/</span> <span class="mf">99.0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span>
                <span class="n">aux_pointer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Mamdani: Consequent is an index to output fuzzy set</span>
                <span class="n">consequent_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">fourth_pointer</span> <span class="o">+</span> <span class="n">aux_pointer</span><span class="p">])</span>
                <span class="n">aux_pointer</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Create rule if it has at least one antecedent</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">init_rule_antecedents</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">rs_instance</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">RuleSimple</span><span class="p">(</span><span class="n">init_rule_antecedents</span><span class="p">,</span> <span class="n">consequent_value</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">rule_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rs_instance</span><span class="p">)</span>

        <span class="c1"># Decode membership functions if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">antecedents_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decode_membership_functions</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">)</span>

            <span class="c1"># Normalize to data domain</span>
            <span class="n">antecedents</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">fuzzy_variable</span><span class="p">,</span> <span class="n">fv_raw</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">antecedents_raw</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorical_boolean_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorical_boolean_mask</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">]:</span>
                    <span class="n">antecedents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fv_raw</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lv_FS</span> <span class="o">=</span> <span class="p">[</span><span class="n">lv</span><span class="o">.</span><span class="n">membership_parameters</span> <span class="k">for</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">fv_raw</span><span class="o">.</span><span class="n">linguistic_variables</span><span class="p">]</span>
                    <span class="n">min_lv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lv_FS</span><span class="p">))</span>
                    <span class="n">max_lv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lv_FS</span><span class="p">))</span>

                    <span class="n">linguistic_variables</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">lx</span><span class="p">,</span> <span class="n">relevant_lv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lv_FS</span><span class="p">):</span>
                        <span class="n">relevant_lv</span> <span class="o">=</span> <span class="p">(</span><span class="n">relevant_lv</span> <span class="o">-</span> <span class="n">min_lv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_lv</span> <span class="o">-</span> <span class="n">min_lv</span><span class="p">)</span> <span class="o">*</span> <span class="n">range_domain</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">]</span> <span class="o">+</span> \
                                      <span class="n">min_domain</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
                            <span class="n">proper_FS</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vl_names</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">][</span><span class="n">lx</span><span class="p">],</span> <span class="n">relevant_lv</span><span class="p">,</span>
                                             <span class="p">(</span><span class="n">min_domain</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">],</span> <span class="n">max_domain</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">]))</span>
                        <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
                            <span class="n">proper_FS</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">IVFS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vl_names</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">][</span><span class="n">lx</span><span class="p">],</span> <span class="n">relevant_lv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">relevant_lv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                               <span class="p">(</span><span class="n">min_domain</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">],</span> <span class="n">max_domain</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">]))</span>
                        <span class="n">linguistic_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proper_FS</span><span class="p">)</span>

                    <span class="n">linguistic_variable</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">fuzzyVariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_names</span><span class="p">[</span><span class="n">fuzzy_variable</span><span class="p">],</span> <span class="n">linguistic_variables</span><span class="p">)</span>
                    <span class="n">antecedents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linguistic_variable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">antecedents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;time_moment&#39;</span><span class="p">]]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">antecedents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span>

        <span class="c1"># Decode output fuzzy sets for Mamdani inference (if needed)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">==</span> <span class="s1">&#39;fuzzy&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Output fuzzy sets are encoded in the gene</span>
            <span class="n">output_fs_pointer</span> <span class="o">=</span> <span class="n">fourth_pointer</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span>
            <span class="n">output_fs_genes</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">output_fs_pointer</span><span class="p">:]</span>
            
            <span class="c1"># Decode similar to input fuzzy sets</span>
            <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
                <span class="n">output_fs_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_output_lvs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
                <span class="n">output_fs_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_output_lvs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span>
            
            <span class="c1"># Decode output membership functions</span>
            <span class="n">decoded_output_fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decode_output_membership_functions</span><span class="p">(</span><span class="n">output_fs_genes</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">)</span>
            
            <span class="c1"># Normalize to output domain [y_min, y_max]</span>
            <span class="c1"># Flatten all parameters to find global min/max</span>
            <span class="n">all_params</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">decoded_output_fs</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lv</span><span class="o">.</span><span class="n">membership_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">all_params</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">min_lv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">all_params</span><span class="p">)</span>
            <span class="n">max_lv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_params</span><span class="p">)</span>
            
            <span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lx</span><span class="p">,</span> <span class="n">output_fs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decoded_output_fs</span><span class="p">):</span>
                <span class="n">relevant_lv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output_fs</span><span class="o">.</span><span class="n">membership_parameters</span><span class="p">)</span>
                <span class="n">relevant_lv</span> <span class="o">=</span> <span class="p">(</span><span class="n">relevant_lv</span> <span class="o">-</span> <span class="n">min_lv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_lv</span> <span class="o">-</span> <span class="n">min_lv</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span>
                <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
                    <span class="n">proper_FS</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Output_</span><span class="si">{</span><span class="n">lx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">relevant_lv</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
                    <span class="n">proper_FS</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">IVFS</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Output_</span><span class="si">{</span><span class="n">lx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">relevant_lv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">relevant_lv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                       <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">))</span>
                <span class="n">output_fuzzy_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proper_FS</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">==</span> <span class="s1">&#39;fuzzy&#39;</span><span class="p">:</span>
            <span class="c1"># Use precomputed output fuzzy sets</span>
            <span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Create rule base</span>
        <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
            <span class="n">rule_base</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">RuleBaseT1</span><span class="p">(</span><span class="n">antecedents</span><span class="p">,</span> <span class="n">rule_list</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
            <span class="n">rule_base</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">RuleBaseT2</span><span class="p">(</span><span class="n">antecedents</span><span class="p">,</span> <span class="n">rule_list</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">gt2</span><span class="p">:</span>
            <span class="n">rule_base</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">RuleBaseGT2</span><span class="p">(</span><span class="n">antecedents</span><span class="p">,</span> <span class="n">rule_list</span><span class="p">)</span>

        <span class="c1"># Store output fuzzy sets in rule base for Mamdani inference</span>
        <span class="k">if</span> <span class="n">output_fuzzy_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rule_base</span><span class="o">.</span><span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="n">output_fuzzy_sets</span>

        <span class="c1"># For regression, we use a single &quot;class&quot; (output is numeric)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">MasterRuleBase</span><span class="p">([</span><span class="n">rule_base</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">],</span> <span class="n">allow_unknown</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_decode_output_membership_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_genes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">:</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Decode output fuzzy sets from gene array.</span>
<span class="sd">        </span>
<span class="sd">        :param output_genes: gene segment containing output FS parameters</span>
<span class="sd">        :param fuzzy_type: type of fuzzy set</span>
<span class="sd">        :return: list of output fuzzy sets</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
            <span class="c1"># Decode T1 fuzzy sets</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">lv_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_output_lvs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lv_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># First FS: triangular (3 parameters)</span>
                    <span class="n">params_tri</span> <span class="o">=</span> <span class="n">output_genes</span><span class="p">[</span><span class="n">pointer</span><span class="p">:</span><span class="n">pointer</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">3</span>
                    <span class="c1"># Convert triangular to trapezoidal: [a, b, c]  [a, b, b, c]</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">params_tri</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params_tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params_tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params_tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Subsequent FSs: trapezoidal (4 parameters)</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="n">output_genes</span><span class="p">[</span><span class="n">pointer</span><span class="p">:</span><span class="n">pointer</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
                    <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">4</span>
                
                <span class="c1"># Parameters are in [0, 99] range, will be normalized later</span>
                <span class="n">fs_instance</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Output_</span><span class="si">{</span><span class="n">lv_idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="n">output_fuzzy_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs_instance</span><span class="p">)</span>
                
        <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
            <span class="c1"># Decode T2 fuzzy sets (interval type-2)</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">lv_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_output_lvs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lv_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># First FS: 2 parameters</span>
                    <span class="n">params_lower</span> <span class="o">=</span> <span class="n">output_genes</span><span class="p">[</span><span class="n">pointer</span><span class="p">:</span><span class="n">pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">params_upper</span> <span class="o">=</span> <span class="n">output_genes</span><span class="p">[</span><span class="n">pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">pointer</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Subsequent FSs: 6 parameters</span>
                    <span class="n">params_lower</span> <span class="o">=</span> <span class="n">output_genes</span><span class="p">[</span><span class="n">pointer</span><span class="p">:</span><span class="n">pointer</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">params_upper</span> <span class="o">=</span> <span class="n">output_genes</span><span class="p">[</span><span class="n">pointer</span> <span class="o">+</span> <span class="mi">3</span><span class="p">:</span><span class="n">pointer</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span>
                    <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">6</span>
                
                <span class="n">fs_instance</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">IVFS</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Output_</span><span class="si">{</span><span class="n">lv_idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">params_lower</span><span class="p">,</span> <span class="n">params_upper</span><span class="p">)</span>
                <span class="n">output_fuzzy_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs_instance</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">output_fuzzy_sets</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate_numpy_fast_regression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">:</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fast vectorized evaluation for regression using RMSE as fitness.</span>
<span class="sd">        </span>
<span class="sd">        Similar to classification version but predicts continuous values and uses MSE/RMSE.</span>
<span class="sd">        </span>
<span class="sd">        :param x: gene array</span>
<span class="sd">        :param y: target values (continuous)</span>
<span class="sd">        :param fuzzy_type: fuzzy set type</span>
<span class="sd">        :return: negative RMSE (to be minimized; negated so higher is better)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">mf_size</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span> <span class="k">else</span> <span class="mi">6</span>

        <span class="c1"># Calculate pointer to consequents (no weights in additive regression)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
                <span class="n">fourth_pointer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span> <span class="o">+</span> \
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
            <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
                <span class="n">fourth_pointer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span> <span class="o">+</span> \
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mf_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fourth_pointer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span>

        <span class="c1"># Get precomputed memberships</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">antecedents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decode_membership_functions</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">)</span>
            <span class="n">precomputed_antecedent_memberships</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">compute_antecedents_memberships</span><span class="p">(</span><span class="n">antecedents</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">precomputed_antecedent_memberships</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_precomputed_truth</span>

        <span class="c1"># Convert x to int array</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Extract gene segments</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">chosen_ants</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">)</span>
        <span class="n">ant_params</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">:</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">)</span>

        <span class="c1"># Clamp parameters</span>
        <span class="k">for</span> <span class="n">feat_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_features</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">chosen_ants</span> <span class="o">==</span> <span class="n">feat_idx</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_param</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lvs</span><span class="p">[</span><span class="n">feat_idx</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">[</span><span class="n">feat_idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">ant_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ant_params</span><span class="p">,</span> <span class="n">max_param</span><span class="p">),</span> <span class="n">ant_params</span><span class="p">)</span>

        <span class="c1"># Build membership array</span>
        <span class="n">max_lvars</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span>
        <span class="n">membership_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span><span class="p">,</span> <span class="n">max_lvars</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">feat_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_features</span><span class="p">):</span>
            <span class="n">feat_memberships</span> <span class="o">=</span> <span class="n">precomputed_antecedent_memberships</span><span class="p">[</span><span class="n">feat_idx</span><span class="p">]</span>
            <span class="n">n_lvars</span> <span class="o">=</span> <span class="n">feat_memberships</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">membership_array</span><span class="p">[:,</span> <span class="n">feat_idx</span><span class="p">,</span> <span class="p">:</span><span class="n">n_lvars</span><span class="p">]</span> <span class="o">=</span> <span class="n">feat_memberships</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Create indicator matrix</span>
        <span class="n">indicators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_features</span><span class="p">,</span> <span class="n">max_lvars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">))</span>
        <span class="n">rule_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">ant_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">indicators</span><span class="p">[</span><span class="n">chosen_ants</span><span class="p">,</span> <span class="n">ant_params</span><span class="p">,</span> <span class="n">rule_indices</span><span class="p">,</span> <span class="n">ant_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Compute memberships</span>
        <span class="n">ant_memberships</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;sfl,flra-&gt;sra&#39;</span><span class="p">,</span> <span class="n">membership_array</span><span class="p">,</span> <span class="n">indicators</span><span class="p">)</span>
        <span class="n">rule_memberships</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">ant_memberships</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Get consequents - different handling for crisp vs fuzzy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">==</span> <span class="s1">&#39;crisp&#39;</span><span class="p">:</span>
            <span class="c1"># Crisp: Denormalize from [0, 99] to [y_min, y_max]</span>
            <span class="n">rule_consequents_normalized</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">fourth_pointer</span><span class="p">:</span><span class="n">fourth_pointer</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">]</span>
            <span class="n">rule_consequents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">rule_consequents_normalized</span> <span class="o">/</span> <span class="mf">99.0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span>

            <span class="c1"># Weighted average</span>
            <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rule_memberships</span> <span class="o">*</span> <span class="n">rule_consequents</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rule_memberships</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span>
            <span class="n">predicted_values</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mamdani: Fuzzy inference with defuzzification</span>
            <span class="c1"># Get consequent indices</span>
            <span class="n">rule_consequent_indices</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">fourth_pointer</span><span class="p">:</span><span class="n">fourth_pointer</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            
            <span class="c1"># Decode output fuzzy sets if needed</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_fs_pointer</span> <span class="o">=</span> <span class="n">fourth_pointer</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span>
                <span class="n">output_fs_genes</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">output_fs_pointer</span><span class="p">:]</span>
                <span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decode_output_membership_functions</span><span class="p">(</span><span class="n">output_fs_genes</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">)</span>
                
                <span class="c1"># Normalize to output domain</span>
                <span class="c1"># Flatten all parameters to find global min/max</span>
                <span class="n">all_params</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">output_fuzzy_sets</span><span class="p">:</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lv</span><span class="o">.</span><span class="n">membership_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">all_params</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="n">min_lv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">all_params</span><span class="p">)</span>
                <span class="n">max_lv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_params</span><span class="p">)</span>
                
                <span class="n">normalized_output_fs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">lx</span><span class="p">,</span> <span class="n">output_fs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_fuzzy_sets</span><span class="p">):</span>
                    <span class="n">relevant_lv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output_fs</span><span class="o">.</span><span class="n">membership_parameters</span><span class="p">)</span>
                    <span class="n">relevant_lv</span> <span class="o">=</span> <span class="p">(</span><span class="n">relevant_lv</span> <span class="o">-</span> <span class="n">min_lv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_lv</span> <span class="o">-</span> <span class="n">min_lv</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span>
                    <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
                        <span class="n">proper_FS</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Output_</span><span class="si">{</span><span class="n">lx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">relevant_lv</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">))</span>
                    <span class="n">normalized_output_fs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proper_FS</span><span class="p">)</span>
                <span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="n">normalized_output_fs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span>
            
            <span class="c1"># Perform Mamdani inference for each sample</span>
            <span class="n">predicted_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mamdani_inference_vectorized</span><span class="p">(</span>
                <span class="n">rule_memberships</span><span class="p">,</span> <span class="n">rule_consequent_indices</span><span class="p">,</span> <span class="n">output_fuzzy_sets</span><span class="p">)</span>

        <span class="c1"># Compute RMSE</span>
        <span class="n">mse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">predicted_values</span><span class="p">)</span>
        <span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mse</span><span class="p">)</span>

        <span class="c1"># Return negative RMSE (so higher fitness is better)</span>
        <span class="c1"># Normalize by y_range to make it scale-independent</span>
        <span class="n">normalized_rmse</span> <span class="o">=</span> <span class="n">rmse</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_range</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">normalized_rmse</span>  <span class="c1"># Negative because pymoo minimizes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_mamdani_inference_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule_memberships</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">rule_consequent_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                                     <span class="n">output_fuzzy_sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Vectorized Mamdani fuzzy inference with centroid defuzzification.</span>
<span class="sd">        </span>
<span class="sd">        :param rule_memberships: array of shape (n_samples, n_rules) with rule firing strengths</span>
<span class="sd">        :param rule_consequent_indices: array of shape (n_rules,) with output FS indices for each rule</span>
<span class="sd">        :param output_fuzzy_sets: list of output fuzzy sets</span>
<span class="sd">        :return: defuzzified predictions array of shape (n_samples,)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">rule_memberships</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_rules</span> <span class="o">=</span> <span class="n">rule_memberships</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Discretized universe</span>
        <span class="n">universe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">universe</span><span class="p">)</span>
        
        <span class="c1"># Compute membership values for all output fuzzy sets at all universe points</span>
        <span class="n">output_memberships</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">output_fuzzy_sets</span><span class="p">),</span> <span class="n">n_points</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">fs_idx</span><span class="p">,</span> <span class="n">output_fs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_fuzzy_sets</span><span class="p">):</span>
            <span class="n">output_memberships</span><span class="p">[</span><span class="n">fs_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">output_fs</span><span class="o">.</span><span class="n">membership</span><span class="p">(</span><span class="n">universe</span><span class="p">)</span>
        
        <span class="c1"># For each sample, aggregate clipped fuzzy sets and defuzzify</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="c1"># Initialize aggregated output membership (start with zeros)</span>
            <span class="n">aggregated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
            
            <span class="c1"># For each rule, clip the consequent fuzzy set by the rule&#39;s firing strength</span>
            <span class="k">for</span> <span class="n">rule_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rules</span><span class="p">):</span>
                <span class="n">firing_strength</span> <span class="o">=</span> <span class="n">rule_memberships</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">,</span> <span class="n">rule_idx</span><span class="p">]</span>
                <span class="n">consequent_idx</span> <span class="o">=</span> <span class="n">rule_consequent_indices</span><span class="p">[</span><span class="n">rule_idx</span><span class="p">]</span>
                
                <span class="c1"># Clip: multiply output FS memberships by firing strength</span>
                <span class="n">clipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">output_memberships</span><span class="p">[</span><span class="n">consequent_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">firing_strength</span><span class="p">)</span>
                
                <span class="c1"># Aggregate: MAX operation (union)</span>
                <span class="n">aggregated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">aggregated</span><span class="p">,</span> <span class="n">clipped</span><span class="p">)</span>
            
            <span class="c1"># Defuzzify using centroid method</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">aggregated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                <span class="n">predictions</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">universe</span> <span class="o">*</span> <span class="n">aggregated</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">aggregated</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No rules fired, use midpoint</span>
                <span class="n">predictions</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        
        <span class="k">return</span> <span class="n">predictions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate_torch_fast_regression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">:</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">return_predictions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        PyTorch GPU-accelerated evaluation for regression.</span>
<span class="sd">        </span>
<span class="sd">        :param x: gene tensor (can be numpy array or torch tensor)</span>
<span class="sd">        :param y: target values tensor (can be numpy array or torch tensor)</span>
<span class="sd">        :param fuzzy_type: enum type for fuzzy set type</span>
<span class="sd">        :param device: device to run computation on (&#39;cuda&#39; or &#39;cpu&#39;)</span>
<span class="sd">        :param return_predictions: if True, return predictions; if False, return R score</span>
<span class="sd">        :return: R score (as Python float) or prediction tensor</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;PyTorch is required for GPU acceleration. Install with: pip install torch&quot;</span><span class="p">)</span>
        
        <span class="c1"># Convert inputs to torch tensors if needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">y_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_torch</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        
        <span class="c1"># Convert training data to torch if not already done</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;X_torch_reg&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_torch_reg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_torch_reg</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        
        <span class="n">mf_size</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span> <span class="k">else</span> <span class="mi">6</span>
        
        <span class="c1"># Calculate pointers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">:</span>
                <span class="n">fourth_pointer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span> <span class="o">+</span> \
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
            <span class="k">elif</span> <span class="n">fuzzy_type</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t2</span><span class="p">:</span>
                <span class="n">fourth_pointer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span> <span class="o">+</span> \
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mf_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fourth_pointer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span>
        
        <span class="c1"># Get precomputed memberships and convert to torch</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Convert to numpy for decoding (membership decoding is complex, keep in numpy)</span>
            <span class="n">x_np</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
            <span class="n">antecedents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decode_membership_functions</span><span class="p">(</span><span class="n">x_np</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">)</span>
            <span class="n">precomputed_antecedent_memberships_np</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">compute_antecedents_memberships</span><span class="p">(</span><span class="n">antecedents</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
            <span class="n">precomputed_antecedent_memberships</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">ant_mems</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> 
                <span class="k">for</span> <span class="n">ant_mems</span> <span class="ow">in</span> <span class="n">precomputed_antecedent_memberships_np</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_precomputed_truth_torch_reg&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_precomputed_truth_torch_reg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_precomputed_truth_torch_reg</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">ant_mems</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> 
                    <span class="k">for</span> <span class="n">ant_mems</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_precomputed_truth</span>
                <span class="p">]</span>
            <span class="n">precomputed_antecedent_memberships</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_precomputed_truth_torch_reg</span>
        
        <span class="c1"># Ensure x is integer type</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
        
        <span class="n">n_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Extract gene segments</span>
        <span class="n">chosen_ants</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">)</span>
        <span class="n">ant_params</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">:</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">)</span>
        
        <span class="c1"># Clamp parameters to valid range</span>
        <span class="k">for</span> <span class="n">ant_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_features</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">chosen_ants</span> <span class="o">==</span> <span class="n">ant_idx</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_param</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lvs</span><span class="p">[</span><span class="n">ant_idx</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lv_possible</span><span class="p">[</span><span class="n">ant_idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">ant_params</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">ant_params</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">max_param</span><span class="p">),</span> <span class="n">ant_params</span><span class="p">)</span>
        
        <span class="c1"># Compute rule memberships (vectorized)</span>
        <span class="n">rule_memberships</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rule_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ant_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">):</span>
                <span class="n">feature</span> <span class="o">=</span> <span class="n">chosen_ants</span><span class="p">[</span><span class="n">rule_idx</span><span class="p">,</span> <span class="n">ant_idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">param</span> <span class="o">=</span> <span class="n">ant_params</span><span class="p">[</span><span class="n">rule_idx</span><span class="p">,</span> <span class="n">ant_idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">rule_memberships</span><span class="p">[:,</span> <span class="n">rule_idx</span><span class="p">]</span> <span class="o">*=</span> <span class="n">precomputed_antecedent_memberships</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="n">param</span><span class="p">,</span> <span class="p">:]</span>
        
        <span class="c1"># Get consequents and handle crisp vs fuzzy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">==</span> <span class="s1">&#39;crisp&#39;</span><span class="p">:</span>
            <span class="c1"># Crisp consequents: denormalize from [0, 99] to [y_min, y_max]</span>
            <span class="n">rule_consequents_normalized</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">fourth_pointer</span><span class="p">:</span><span class="n">fourth_pointer</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">]</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="n">rule_consequents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">rule_consequents_normalized</span> <span class="o">/</span> <span class="mf">99.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_mode</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                <span class="c1"># Weighted average</span>
                <span class="n">numerator</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rule_memberships</span> <span class="o">*</span> <span class="n">rule_consequents</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rule_memberships</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span>
                <span class="n">predictions</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># sufficient mode</span>
                <span class="c1"># Winner-takes-all</span>
                <span class="n">max_memberships</span><span class="p">,</span> <span class="n">max_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rule_memberships</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">predictions</span> <span class="o">=</span> <span class="n">rule_consequents</span><span class="p">[</span><span class="n">max_indices</span><span class="p">]</span>
                <span class="c1"># Set to mean for samples with no active rules</span>
                <span class="n">predictions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_memberships</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_torch</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fuzzy consequents: Mamdani inference (currently not GPU-optimized, fall back to numpy)</span>
            <span class="n">x_np</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="n">predictions_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mamdani_inference_vectorized</span><span class="p">(</span><span class="n">x_np</span><span class="p">,</span> <span class="n">fourth_pointer</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">)</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predictions_np</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_predictions</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">predictions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute R score</span>
            <span class="n">ss_res</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y_torch</span> <span class="o">-</span> <span class="n">predictions</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ss_tot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y_torch</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_torch</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ss_res</span> <span class="o">/</span> <span class="p">(</span><span class="n">ss_tot</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r2</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

<div class="viewcode-block" id="FitRuleBaseRegression.has_torch_eval">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.FitRuleBaseRegression.has_torch_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_torch_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Check if PyTorch evaluation is available.</span>
<span class="sd">        </span>
<span class="sd">        :return: True if torch is available, False otherwise</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Evaluation function for regression problem.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_numpy_fast_regression</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_type</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">score</span>  <span class="c1"># Pymoo minimizes, we want to maximize (minimize -score)</span>

<div class="viewcode-block" id="FitRuleBaseRegression.fitness_func">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.FitRuleBaseRegression.fitness_func">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fitness_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ruleBase</span><span class="p">:</span> <span class="n">rules</span><span class="o">.</span><span class="n">RuleBase</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">precomputed_truth</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fitness function for regression using RMSE.</span>
<span class="sd">        </span>
<span class="sd">        :param ruleBase: RuleBase object</span>
<span class="sd">        :param X: input samples</span>
<span class="sd">        :param y: target values</span>
<span class="sd">        :param tolerance: tolerance for rule evaluation</span>
<span class="sd">        :param alpha: weight for rule size penalty</span>
<span class="sd">        :param beta: weight for average antecedents penalty</span>
<span class="sd">        :param precomputed_truth: precomputed membership values</span>
<span class="sd">        :return: fitness value (higher is better)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">precomputed_truth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precomputed_truth</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">compute_antecedents_memberships</span><span class="p">(</span><span class="n">ruleBase</span><span class="o">.</span><span class="n">antecedents</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>

        <span class="c1"># Predict using the rule base - different for crisp vs fuzzy consequents</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">==</span> <span class="s1">&#39;crisp&#39;</span><span class="p">:</span>
            <span class="c1"># Crisp inference</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">sample_memberships</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">sample_consequents</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">ruleBase</span><span class="o">.</span><span class="n">get_rules</span><span class="p">():</span>
                    <span class="c1"># Compute rule membership for this sample</span>
                    <span class="n">membership</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">for</span> <span class="n">ant_idx</span><span class="p">,</span> <span class="n">ant_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">antecedents</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ant_val</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># not don&#39;t care</span>
                            <span class="n">ant_val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ant_val</span><span class="p">)</span>
                            <span class="n">membership</span> <span class="o">*=</span> <span class="n">precomputed_truth</span><span class="p">[</span><span class="n">ant_idx</span><span class="p">][</span><span class="n">ant_val</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

                    <span class="c1"># Filter by tolerance if using sufficient rules</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_mode</span> <span class="o">==</span> <span class="s1">&#39;sufficient&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">membership</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                            <span class="n">sample_memberships</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">membership</span><span class="p">)</span>
                            <span class="n">sample_consequents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">consequent</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># additive mode (default)</span>
                        <span class="n">sample_memberships</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">membership</span><span class="p">)</span>
                        <span class="n">sample_consequents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">consequent</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_memberships</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Weighted average</span>
                    <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_memberships</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_consequents</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_memberships</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># No rules (can happen with sufficient mode), use mean</span>
                    <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

                <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mamdani inference</span>
            <span class="c1"># Compute rule memberships for all samples</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_rules</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ruleBase</span><span class="o">.</span><span class="n">get_rules</span><span class="p">())</span>
            <span class="n">rule_memberships</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_rules</span><span class="p">))</span>
            <span class="n">rule_consequent_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_rules</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">rule_idx</span><span class="p">,</span> <span class="n">rule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ruleBase</span><span class="o">.</span><span class="n">get_rules</span><span class="p">()):</span>
                <span class="n">rule_consequent_indices</span><span class="p">[</span><span class="n">rule_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">consequent</span><span class="p">)</span>
                
                <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
                    <span class="n">membership</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">for</span> <span class="n">ant_idx</span><span class="p">,</span> <span class="n">ant_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">antecedents</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ant_val</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">ant_val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ant_val</span><span class="p">)</span>
                            <span class="n">membership</span> <span class="o">*=</span> <span class="n">precomputed_truth</span><span class="p">[</span><span class="n">ant_idx</span><span class="p">][</span><span class="n">ant_val</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">]</span>
                    <span class="n">rule_memberships</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">,</span> <span class="n">rule_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">membership</span>
            
            <span class="c1"># Get output fuzzy sets from rule base</span>
            <span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="n">ruleBase</span><span class="o">.</span><span class="n">output_fuzzy_sets</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ruleBase</span><span class="p">,</span> <span class="s1">&#39;output_fuzzy_sets&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span>
            
            <span class="c1"># Perform Mamdani inference</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mamdani_inference_vectorized</span><span class="p">(</span>
                <span class="n">rule_memberships</span><span class="p">,</span> <span class="n">rule_consequent_indices</span><span class="p">,</span> <span class="n">output_fuzzy_sets</span><span class="p">)</span>

        <span class="c1"># Compute RMSE</span>
        <span class="n">mse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mse</span><span class="p">)</span>
        <span class="n">normalized_rmse</span> <span class="o">=</span> <span class="n">rmse</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_range</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>

        <span class="c1"># Base score (negative RMSE, normalized)</span>
        <span class="n">score_acc</span> <span class="o">=</span> <span class="o">-</span><span class="n">normalized_rmse</span>

        <span class="c1"># Penalize complexity</span>
        <span class="n">ruleBase</span><span class="o">.</span><span class="n">purge_rules</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ruleBase</span><span class="o">.</span><span class="n">get_rules</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">avg_antecedents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">antecedents</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ruleBase</span><span class="o">.</span><span class="n">get_rules</span><span class="p">()])</span>
            <span class="n">score_rules_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">avg_antecedents</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">)</span>
            <span class="n">score_nrules</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ruleBase</span><span class="o">.</span><span class="n">get_rules</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">)</span>

            <span class="n">score</span> <span class="o">=</span> <span class="n">score_acc</span> <span class="o">+</span> <span class="n">score_rules_size</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">+</span> <span class="n">score_nrules</span> <span class="o">*</span> <span class="n">beta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>  <span class="c1"># Very bad score if no rules</span>

        <span class="k">return</span> <span class="n">score</span></div>
</div>



<div class="viewcode-block" id="BaseFuzzyRulesRegressor">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.BaseFuzzyRulesRegressor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseFuzzyRulesRegressor</span><span class="p">(</span><span class="n">RegressorMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Fuzzy rule-based regressor with evolutionary optimization.</span>
<span class="sd">    </span>
<span class="sd">    Similar interface to BaseFuzzyRulesClassifier but for regression problems.</span>
<span class="sd">    Rules output numeric values instead of class labels.</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="BaseFuzzyRulesRegressor.__init__">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.BaseFuzzyRulesRegressor.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nRules</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">nAnts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">fuzzy_type</span><span class="p">:</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">FUZZY_SETS</span><span class="o">.</span><span class="n">t1</span><span class="p">,</span>
                 <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_linguistic_variables</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">linguistic_variables</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">fuzzyVariable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">categorical_mask</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">precomputed_rules</span><span class="p">:</span> <span class="n">rules</span><span class="o">.</span><span class="n">MasterRuleBase</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">runner</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">rule_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;additive&#39;</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;pymoo&#39;</span><span class="p">,</span>
                 <span class="n">consequent_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;crisp&#39;</span><span class="p">,</span> <span class="n">output_fuzzy_sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_output_linguistic_variables</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">universe_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize fuzzy rules regressor.</span>

<span class="sd">        :param nRules: number of rules to optimize</span>
<span class="sd">        :param nAnts: max number of antecedents per rule</span>
<span class="sd">        :param fuzzy_type: type of fuzzy set (t1, t2, etc.)</span>
<span class="sd">        :param tolerance: tolerance for rule evaluation</span>
<span class="sd">        :param y_range: tuple (min, max) for output range. If None, computed from data</span>
<span class="sd">        :param n_linguistic_variables: number of linguistic variables per feature</span>
<span class="sd">        :param verbose: print optimization progress</span>
<span class="sd">        :param linguistic_variables: precomputed fuzzy variables</span>
<span class="sd">        :param categorical_mask: mask for categorical features</span>
<span class="sd">        :param domain: domain for each input feature</span>
<span class="sd">        :param precomputed_rules: precomputed rule base</span>
<span class="sd">        :param runner: number of threads for parallel evaluation</span>
<span class="sd">        :param rule_mode: &#39;additive&#39; (all rules contribute) or &#39;sufficient&#39; (only rules above tolerance)</span>
<span class="sd">        :param backend: evolutionary backend (&#39;pymoo&#39; or &#39;evox&#39;)</span>
<span class="sd">        :param consequent_type: &#39;crisp&#39; (numeric outputs) or &#39;fuzzy&#39; (fuzzy set outputs with defuzzification)</span>
<span class="sd">        :param output_fuzzy_sets: precomputed output fuzzy sets for Mamdani inference. If None, will be evolved</span>
<span class="sd">        :param n_output_linguistic_variables: number of output linguistic variables (if not precomputed)</span>
<span class="sd">        :param universe_points: number of discretization points for fuzzy inference</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nRules</span> <span class="o">=</span> <span class="n">nRules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span> <span class="o">=</span> <span class="n">nAnts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_type</span> <span class="o">=</span> <span class="n">fuzzy_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>  <span class="c1"># Used in &#39;sufficient&#39; mode, ignored in &#39;additive&#39; mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rule_mode</span> <span class="o">=</span> <span class="n">rule_mode</span>  <span class="c1"># &#39;additive&#39; or &#39;sufficient&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span> <span class="o">=</span> <span class="n">y_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_linguist_variables</span> <span class="o">=</span> <span class="n">n_linguistic_variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="o">=</span> <span class="n">linguistic_variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">categorical_mask</span> <span class="o">=</span> <span class="n">categorical_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precomputed_rules</span> <span class="o">=</span> <span class="n">precomputed_rules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_loss</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="mf">0.0</span>
        
        <span class="c1"># Mamdani fuzzy inference parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">=</span> <span class="n">consequent_type</span>  <span class="c1"># &#39;crisp&#39; or &#39;fuzzy&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="n">output_fuzzy_sets</span>  <span class="c1"># Precomputed output FSs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_output_linguistic_variables</span> <span class="o">=</span> <span class="n">n_output_linguistic_variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe_points</span> <span class="o">=</span> <span class="n">universe_points</span>  <span class="c1"># Discretization for Mamdani</span>

        <span class="c1"># Initialize evolutionary backend</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">ev_backends</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using evolutionary backend: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Falling back to pymoo backend.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">ev_backends</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;pymoo&#39;</span><span class="p">)</span>

        <span class="c1"># Thread runner</span>
        <span class="k">if</span> <span class="n">runner</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="n">runner</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thread_runner</span> <span class="o">=</span> <span class="n">StarmapParallelization</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thread_runner</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">precomputed_rules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span> <span class="o">=</span> <span class="n">precomputed_rules</span></div>


<div class="viewcode-block" id="BaseFuzzyRulesRegressor.fit">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.BaseFuzzyRulesRegressor.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">n_gen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
            <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">33</span><span class="p">,</span> <span class="n">var_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">sbx_eta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
            <span class="n">mutation_eta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">7.0</span><span class="p">,</span> <span class="n">tournament_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fit the regressor to training data.</span>

<span class="sd">        :param X: input features (n_samples, n_features)</span>
<span class="sd">        :param y: target values (n_samples,)</span>
<span class="sd">        :param n_gen: number of generations</span>
<span class="sd">        :param pop_size: population size</span>
<span class="sd">        :param random_state: random seed</span>
<span class="sd">        :param var_prob: crossover probability</span>
<span class="sd">        :param sbx_eta: SBX eta parameter</span>
<span class="sd">        :param mutation_eta: mutation eta parameter</span>
<span class="sd">        :param tournament_size: tournament selection size</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">lvs_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lvs_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="c1"># Determine output range if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span>

        <span class="c1"># Create optimization problem</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">FitRuleBaseRegression</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">nRules</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="p">,</span> <span class="n">nAnts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="p">,</span>
            <span class="n">y_range</span><span class="o">=</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span> <span class="n">thread_runner</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thread_runner</span><span class="p">,</span>
            <span class="n">linguistic_variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lvs</span><span class="p">,</span>
            <span class="n">consequent_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span><span class="p">,</span>
            <span class="n">output_fuzzy_sets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span><span class="p">,</span>
            <span class="n">n_output_linguistic_variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_output_linguistic_variables</span><span class="p">,</span>
            <span class="n">universe_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">universe_points</span><span class="p">,</span>
            <span class="n">n_linguistic_variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_linguist_variables</span><span class="p">,</span>
            <span class="n">fuzzy_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_type</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">categorical_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">categorical_mask</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta_</span><span class="p">,</span>
            <span class="n">rule_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_mode</span><span class="p">,</span> <span class="n">backend_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Run optimization using selected backend</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span>
            <span class="n">problem</span><span class="o">=</span><span class="n">problem</span><span class="p">,</span>
            <span class="n">n_gen</span><span class="o">=</span><span class="n">n_gen</span><span class="p">,</span>
            <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">var_prob</span><span class="o">=</span><span class="n">var_prob</span><span class="p">,</span>
            <span class="n">sbx_eta</span><span class="o">=</span><span class="n">sbx_eta</span><span class="p">,</span>
            <span class="n">mutation_eta</span><span class="o">=</span><span class="n">mutation_eta</span><span class="p">,</span>
            <span class="n">tournament_size</span><span class="o">=</span><span class="n">tournament_size</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
        <span class="p">)</span>

        <span class="c1"># Extract best solution</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">best_gene</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">):</span>
            <span class="n">best_gene</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">X</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">best_gene</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Construct final rule base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">_construct_ruleBase_regression</span><span class="p">(</span><span class="n">best_gene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">rule_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">antecedents</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">lvs</span>
        
        <span class="c1"># Store the scalar y_range and bounds for predictions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_range_scalar</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">y_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">y_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">y_max</span>
        
        <span class="c1"># ADDITIVE REGRESSION: Keep all rules (no filtering by tolerance)</span>
        <span class="c1"># All rules contribute to the final prediction weighted by their membership</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimization complete. Final rule base has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">get_rules</span><span class="p">())</span><span class="si">}</span><span class="s2"> rules.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseFuzzyRulesRegressor.predict">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.BaseFuzzyRulesRegressor.predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Predict target values for input samples.</span>

<span class="sd">        :param X: input features (n_samples, n_features)</span>
<span class="sd">        :return: predicted values (n_samples,)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">values</span>

        <span class="n">precomputed_truth</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">compute_antecedents_memberships</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">antecedents</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span> <span class="o">==</span> <span class="s1">&#39;crisp&#39;</span><span class="p">:</span>
            <span class="c1"># Crisp inference</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">sample_memberships</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">sample_consequents</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">get_rules</span><span class="p">():</span>
                    <span class="c1"># Compute rule membership</span>
                    <span class="n">membership</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">for</span> <span class="n">ant_idx</span><span class="p">,</span> <span class="n">ant_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">antecedents</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ant_val</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># not don&#39;t care</span>
                            <span class="n">ant_val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ant_val</span><span class="p">)</span>
                            <span class="n">membership</span> <span class="o">*=</span> <span class="n">precomputed_truth</span><span class="p">[</span><span class="n">ant_idx</span><span class="p">][</span><span class="n">ant_val</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

                    <span class="c1"># Filter by rule_mode: &#39;sufficient&#39; uses tolerance, &#39;additive&#39; includes all</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_mode</span> <span class="o">==</span> <span class="s1">&#39;sufficient&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">membership</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">:</span>
                            <span class="n">sample_memberships</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">membership</span><span class="p">)</span>
                            <span class="n">sample_consequents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">consequent</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># additive mode (default)</span>
                        <span class="n">sample_memberships</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">membership</span><span class="p">)</span>
                        <span class="n">sample_consequents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">consequent</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_memberships</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Weighted average</span>
                    <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_memberships</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_consequents</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_memberships</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># No rules fired (can happen with sufficient mode), use midpoint</span>
                    <span class="n">pred</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

                <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mamdani inference</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_rules</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">get_rules</span><span class="p">())</span>
            <span class="n">rule_memberships</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_rules</span><span class="p">))</span>
            <span class="n">rule_consequent_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_rules</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">rule_idx</span><span class="p">,</span> <span class="n">rule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">get_rules</span><span class="p">()):</span>
                <span class="n">rule_consequent_indices</span><span class="p">[</span><span class="n">rule_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">consequent</span><span class="p">)</span>
                
                <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
                    <span class="n">membership</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">for</span> <span class="n">ant_idx</span><span class="p">,</span> <span class="n">ant_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">antecedents</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ant_val</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">ant_val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ant_val</span><span class="p">)</span>
                            <span class="n">membership</span> <span class="o">*=</span> <span class="n">precomputed_truth</span><span class="p">[</span><span class="n">ant_idx</span><span class="p">][</span><span class="n">ant_val</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">]</span>
                    <span class="n">rule_memberships</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">,</span> <span class="n">rule_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">membership</span>
            
            <span class="c1"># Get output fuzzy sets</span>
            <span class="n">rule_base_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">rule_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">output_fuzzy_sets</span> <span class="o">=</span> <span class="n">rule_base_obj</span><span class="o">.</span><span class="n">output_fuzzy_sets</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rule_base_obj</span><span class="p">,</span> <span class="s1">&#39;output_fuzzy_sets&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fuzzy_sets</span>
            
            <span class="c1"># Create discretized universe</span>
            <span class="n">universe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe_points</span><span class="p">)</span>
            
            <span class="c1"># Perform Mamdani inference</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mamdani_inference_predict</span><span class="p">(</span>
                <span class="n">rule_memberships</span><span class="p">,</span> <span class="n">rule_consequent_indices</span><span class="p">,</span> <span class="n">output_fuzzy_sets</span><span class="p">,</span> <span class="n">universe</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">predictions</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_mamdani_inference_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule_memberships</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">rule_consequent_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                                   <span class="n">output_fuzzy_sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">FS</span><span class="p">],</span> <span class="n">universe</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Mamdani fuzzy inference with centroid defuzzification for prediction.</span>
<span class="sd">        </span>
<span class="sd">        :param rule_memberships: array of shape (n_samples, n_rules) with rule firing strengths</span>
<span class="sd">        :param rule_consequent_indices: array of shape (n_rules,) with output FS indices for each rule</span>
<span class="sd">        :param output_fuzzy_sets: list of output fuzzy sets</span>
<span class="sd">        :param universe: discretized universe of discourse</span>
<span class="sd">        :return: defuzzified predictions array of shape (n_samples,)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">rule_memberships</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_rules</span> <span class="o">=</span> <span class="n">rule_memberships</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">universe</span><span class="p">)</span>
        
        <span class="c1"># Compute membership values for all output fuzzy sets at all universe points</span>
        <span class="n">output_memberships</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">output_fuzzy_sets</span><span class="p">),</span> <span class="n">n_points</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">fs_idx</span><span class="p">,</span> <span class="n">output_fs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_fuzzy_sets</span><span class="p">):</span>
            <span class="n">output_memberships</span><span class="p">[</span><span class="n">fs_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">output_fs</span><span class="o">.</span><span class="n">membership</span><span class="p">(</span><span class="n">universe</span><span class="p">)</span>
        
        <span class="c1"># For each sample, aggregate clipped fuzzy sets and defuzzify</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sample_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="c1"># Initialize aggregated output membership (start with zeros)</span>
            <span class="n">aggregated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
            
            <span class="c1"># For each rule, clip the consequent fuzzy set by the rule&#39;s firing strength</span>
            <span class="k">for</span> <span class="n">rule_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rules</span><span class="p">):</span>
                <span class="n">firing_strength</span> <span class="o">=</span> <span class="n">rule_memberships</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">,</span> <span class="n">rule_idx</span><span class="p">]</span>
                <span class="n">consequent_idx</span> <span class="o">=</span> <span class="n">rule_consequent_indices</span><span class="p">[</span><span class="n">rule_idx</span><span class="p">]</span>
                
                <span class="c1"># Clip: multiply output FS memberships by firing strength</span>
                <span class="n">clipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">output_memberships</span><span class="p">[</span><span class="n">consequent_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">firing_strength</span><span class="p">)</span>
                
                <span class="c1"># Aggregate: MAX operation (union)</span>
                <span class="n">aggregated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">aggregated</span><span class="p">,</span> <span class="n">clipped</span><span class="p">)</span>
            
            <span class="c1"># Defuzzify using centroid method</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">aggregated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                <span class="n">predictions</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">universe</span> <span class="o">*</span> <span class="n">aggregated</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">aggregated</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No rules fired, use midpoint</span>
                <span class="n">predictions</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        
        <span class="k">return</span> <span class="n">predictions</span>

<div class="viewcode-block" id="BaseFuzzyRulesRegressor.score">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.BaseFuzzyRulesRegressor.score">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute R score on test data.</span>

<span class="sd">        :param X: input features</span>
<span class="sd">        :param y: true target values</span>
<span class="sd">        :return: R score</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r2_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseFuzzyRulesRegressor.__str__">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.BaseFuzzyRulesRegressor.__str__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        String representation showing the regression rules.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;rule_base&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;BaseFuzzyRulesRegressor (not fitted)&quot;</span>
        
        <span class="n">output</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;BaseFuzzyRulesRegressor with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">get_rules</span><span class="p">())</span><span class="si">}</span><span class="s2"> rules &quot;</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;(mode: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_mode</span><span class="si">}</span><span class="s2">, consequent: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">80</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">print_rules_regression</span><span class="p">(</span><span class="n">return_rules</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="BaseFuzzyRulesRegressor.__repr__">
<a class="viewcode-back" href="../../api/regression.html#ex_fuzzy.evolutionary_fit_regression.BaseFuzzyRulesRegressor.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Developer-friendly representation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;rule_base&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;BaseFuzzyRulesRegressor(nRules=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nRules</span><span class="si">}</span><span class="s2">, nAnts=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="si">}</span><span class="s2">, rule_mode=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_mode</span><span class="si">}</span><span class="s2">&#39;, consequent_type=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span><span class="si">}</span><span class="s2">&#39;, not fitted)&quot;</span>
        
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;BaseFuzzyRulesRegressor(nRules=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_base</span><span class="o">.</span><span class="n">get_rules</span><span class="p">())</span><span class="si">}</span><span class="s2">, nAnts=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nAnts</span><span class="si">}</span><span class="s2">, rule_mode=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rule_mode</span><span class="si">}</span><span class="s2">&#39;, consequent_type=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">consequent_type</span><span class="si">}</span><span class="s2">&#39;, fuzzy_type=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_type</span><span class="si">}</span><span class="s2">)&quot;</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2023-2025, Javier Fumanal Idocin.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>